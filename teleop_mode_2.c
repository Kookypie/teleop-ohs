#pragma config(Motor,  motorA,          maindrivemotor, tmotorNXT, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"  //Include file to "handle" the BluetoothÂ® messages.

bool safety_drive_motors = true; /* Safety for drive motors to stop if the reach zero */

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                    initializeRobot
//
// Prior to the start of tele-op mode, you may want to perform some initialization on your robot
// and the variables within your program.
//
// In most cases, you may not have to add any code to this function and it will remain "empty".
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

void initializeRobot()
{
	// Place code here to sinitialize servos to starting positions.
	// Sensors are automatically configured and setup by ROBOTC. They may need a brief time to stabilize.


	/* Face the servos straight ahead. */

	wait1Msec(100); /* Wait 100 miliseconds */

	return;
}


/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                         Main Task
//
// The following is the main code for the tele-op robot operation. Customize as appropriate for
// your specific robot.
//
// Game controller / joystick information is sent periodically (about every 50 milliseconds) from
// the FMS (Field Management System) to the robot. Most tele-op programs will follow the following
// logic:
//   1. Loop forever repeating the following actions:
//   2. Get the latest game controller / joystick settings that have been received from the PC.
//   3. Perform appropriate actions based on the joystick + buttons settings. This is usually a
//      simple action:
//      *  Joystick values are usually directly translated into power levels for a motor or
//         position of a servo.
//      *  Buttons are usually used to start/stop a motor or cause a servo to move to a specific
//         position.
//   4. Repeat the loop.
//
// Your program needs to continuously loop because you need to continuously respond to changes in
// the game controller settings.
//
// At the end of the tele-op period, the FMS will autonmatically abort (stop) execution of the program.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

task main()
{
	initializeRobot();

	waitForStart();   // wait for start of tele-op phase

	while (true)
	{
		///////////////////////////////////////////////////////////
		///////////////////////////////////////////////////////////
		////                                                   ////
		////      Add your robot specific tele-op code here.   ////
		////                                                   ////
		///////////////////////////////////////////////////////////
		///////////////////////////////////////////////////////////

		getJoystickSettings(joystick);




/////////////////////////////////////////////////////////////////////////////////
		/* START CODE FOR RIGHT JOYSTICK Y AXIS */
/////////////////////////////////////////////////////////////////////////////////


		// Code for LEFT Y-AXIS (note: Drive Speed : Joystick Left Y-Axis is LINEAR)
		// Negative values indicate forward drive power
		// Positive values indicate reverse drive power

		if ( joystick.joy1_y1 != 0 && joystick.joy1_y1 > 0 ) {
			/* Code for going forward */


			/* Define a variable for our programming function, which
			will certainly be a decimal number, so we define it
			as a 'float' variable. */
			float fController_input;

			/* Convert the number from negative to positive (no plus sign) */
			fController_input = abs(joystick.joy1_y1);

			/* Divide the input by 1.28 */
			fController_input = (fController_input / 1.28);

			/* Define an integer variable explicitally for the motor(s) */
			int iController_input;

			/* Round the value to a whole number, because motors can only
			take in integers (whole numbers that are negative, neutral
			[zero is the only neutral number], or positive) as a value.*/
		  fController_input = round(fController_input);

			/* Place the "supposeably" decimal value to an integer
			value. It is supposeably because we defined and processed
			the controller value in a 'float' variable, which in
			this programming language is just a fancy word for saying
			a decimal number, but its actually stored as a whole number
			right now. We do this as a safety to prevent any errors of
			sending a decimal value to the motor(s) which will result in
			an error.*/
			iController_input = fController_input;

			/* Send a request to the motor to go 'x' speed */
			motor[motorA] = iController_input;


			} else if ( joystick.joy1_y1 != 0 && joystick.joy1_y1 < 0 ) {
			/* Code for going backwards */

			/* Define a variable for our programming function, which
			will certainly be a decimal number, so we define it
			as a 'float' variable. */
			float fController_input;

			/* Convert the number from positive to negative */
			fController_input = ( joystick.joy1_y1 / -1 );

			/* Divide the input by 1.27 */
			fController_input = ( fController_input / 1.27 );

			/* Define an integer variable explicitally for the motor(s) */
			int iController_input;

			/* Round the value to a whole number, because motors can only
			take in integers (whole numbers that are negative, neutral
			[zero is the only neutral number], or positive) as a value.*/
			fController_input = round(fController_input);

			/* Place the "supposeably" decimal value to an integer
			value. It is supposeably because we defined and processed
			the controller value in a 'float' variable, which in
			this programming language is just a fancy word for saying
			a decimal number, but its actually stored as a whole number
			right now. We do this as a safety to prevent any errors of
			sending a decimal value to the motor(s) which will result in
			an error.*/
			iController_input = fController_input;

			/* Send a request to the motor to go '-x' speed */
			motor[motorA] = iController_input;


			} else {
			/* If nothing applies for the Joystick-1 Y axis */


			if ( safety_drive_motors == true ) {
				/* If nether is true we will assume it is zero
				or if some unprogrammed-value or error appears this
				will be used as a safety feature; in other words TURN THE
				MOTOR(S) OFF! */

				motor[motorA] = 0;

				} else if ( safety_drive_motors == false ) {
				/* Drive motors safety feature is disabled, so do nothing.
				We will assume since the user disabled the safety that
				he or she knows what they are doing. */
			}

		}
/////////////////////////////////////////////////////////////////////////////////
		/* END CODE FOR RIGHT JOYSTICK Y AXIS */
/////////////////////////////////////////////////////////////////////////////////




		/* Code for servo that manipulates the main drive motor. */
/////////////////////////////////////////////////////////////////////////////////
		/* START CODE FOR LEFT JOYSTICK X AXIS */
/////////////////////////////////////////////////////////////////////////////////



/////////////////////////////////////////////////////////////////////////////////
		/* END CODE FOR LEFT JOYSTICK X AXIS */
/////////////////////////////////////////////////////////////////////////////////
	}
}
